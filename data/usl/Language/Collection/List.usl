import Language.FlowControl.if as if

// An immutable, single linked list.
// This list cannot be created empty.
// The language being dynamically typed, check for emptynes by invoking isNil on your object.
// Stephane Magnenat <stephane at magnenat dot net> - 2008

private def List(element, next) := (
	
	// Returns a list resulting from the concatenation of element x at the beginning and this list afterwards
	def prepend(x) := List(x, this)
	
	// Returns a list resulting from the concatenation of this list at the beginning and element x afterwards
	def append(x) := {
		if (next.isNil)
			List(x, Nil)
		else
			List(element, next.append(x))
	}
	
	// Returns a list resulting from the concatenation of this list at the beginning and element x afterwards
	def .(x) := append(x)
	
	// Returns a list resulting from the concatenation of list x at the end of this list
	def concat (x:List) := {
		if (next.isNil)
			List(element, x)
		else
			List(element, next.concat(e))
	}
	
	def map(function) := {
		val mappedElement := function(element)
		val mappedNext := {
			if (next.isNil)
				Nil
			else
				next.map(function)
		}
		List(mappedElement, mappedNext)
	}
	
	def foreach(function) := {
		function(element)
		if (!next.isNil)
			next.foreach(function)
	}
	
	def contains(x) := {
		if (x == element)
			true
		else if (!next.isNil)
			next.contains(x)
		else
			false
	}
	/*
	// Returns a list consiting of the elements of this list in the reverse order
	def reverse := {
		
		if (next.isNil)
			List(
		else
			List(element, Nil)
	}
	*/
)

def list(elements:Array) := {
	def buildfromend(n) := {
		if (n + 1 == size)
			List(elements[n], Nil)
		else
			List(elements[n], buildfromend(n+1))
	}
	if (elements.size == 0)
		Nil
	else
		buildfromend(elements.size)
}

// we should be able to write:
val a := list [1, 2, 3, 4]
