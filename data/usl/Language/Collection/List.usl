import Language.FlowControl.if as if

// An immutable, single linked list.
// This list cannot be created empty.
// The language being dynamically typed, check for emptynes by invoking isNil on your object.
// Stephane Magnenat <stephane at magnenat dot net> - 2008

private def List(element, next) := (
	
	// Returns a list resulting from the concatenation of element x at the beginning and this list afterwards
	def prepend(x) := List(x, this)
	
	// Returns a list resulting from the concatenation of this list at the beginning and element x afterwards
	def append(x) := {
		if (next.isNil)
			List(x, Nil)
		else
			List(element, next.append(x))
	}
	
	// Returns a list resulting from the concatenation of this list at the beginning and element x afterwards
	def .(x) := append(x)
	
	// Returns a list resulting from the concatenation of list x at the end of this list
	def concat (x:List) := {
		if (next.isNil)
			List(element, x)
		else
			List(element, next.concat(e))
	}
	
	def map(function) := {
		val mappedElement := function(element)
		val mappedNext := {
			if (next.isNil)
				Nil
			else
				next.map(function)
		}
		List(mappedElement, mappedNext)
	}
	
	def foreach(function) := {
		function(element)
		if (!next.isNil)
			next.foreach(function)
	}
	
	def contains(x) := {
		if (x == element)
			true
		else if (!next.isNil)
			next.contains(x)
		else
			false
	}
	/*
	// Returns a list consiting of the elements of this list in the reverse order
	def reverse := {
		
		if (next.isNil)
			List(
		else
			List(element, Nil)
	}
	*/
)


def list(elements:Array) := {
	def build(i, l) := {
		if (i < 0)
			l
		else
			build(i - 1, List(elements at i, l))
	}
	build(elements.size - 1, Nil)
}

// we should be able to write:
val a := list [1, 2, 3, 4]
